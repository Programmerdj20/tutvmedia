---
import type { MovieResult } from '../types/movie';
import MovieCard from './MovieCard.astro';

export interface Props {
	title: string;
	subtitle?: string;
	movies: MovieResult[];
}

const { title, subtitle, movies } = Astro.props;
const id = `carousel-${title.replace(/\s+/g, '-').toLowerCase()}`;
---

<section class="py-12">
	<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
		<div class="mb-8">
			<h2 class="text-3xl font-bold text-gray-900 mb-2">
				{title}
			</h2>
			{subtitle && <p class="text-gray-600">{subtitle}</p>}
		</div>

		<div class="relative">
			<div
				class="overflow-hidden"
				id={id}
			>
				<div class="flex gap-6 pb-4">
					{/* Películas originales */}
					{movies.map((movie) => (
						<div class="flex-none w-[200px] sm:w-[240px]">
							<MovieCard movie={movie} />
						</div>
					))}
					{/* Películas duplicadas para loop infinito */}
					{movies.map((movie) => (
						<div class="flex-none w-[200px] sm:w-[240px]">
							<MovieCard movie={movie} />
						</div>
					))}
				</div>
			</div>

			<!-- Botones de navegación -->
			<button
				class="carousel-prev absolute left-0 top-1/2 -translate-y-1/2 -translate-x-16 sm:-translate-x-4 z-10 bg-white hover:bg-blue-50 border border-blue-200 rounded-full p-2 transition-all duration-200 opacity-0 group-hover:opacity-100"
				data-carousel={id}
				aria-label="Anterior"
			>
				<svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
				</svg>
			</button>

			<button
				class="carousel-next absolute right-0 top-1/2 -translate-y-1/2 translate-x-16 sm:translate-x-4 z-10 bg-white hover:bg-blue-50 border border-blue-200 rounded-full p-2 transition-all duration-200 opacity-0 group-hover:opacity-100"
				data-carousel={id}
				aria-label="Siguiente"
			>
				<svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
				</svg>
			</button>
		</div>
	</div>
</section>

<script define:vars={{ id }}>
	// Carrusel con scroll automático y manual
	const carousel = document.getElementById(id);
	const prevBtn = document.querySelector(`[data-carousel="${id}"].carousel-prev`);
	const nextBtn = document.querySelector(`[data-carousel="${id}"].carousel-next`);

	const scrollAmount = 300;
	let autoScrollInterval;
	let isUserInteracting = false;

	// Función para hacer scroll de 1 en 1 con animación suave
	const scrollOneItem = () => {
		if (carousel && !isUserInteracting) {
			carousel.scrollTo({
				left: carousel.scrollLeft + scrollAmount,
				behavior: 'smooth'
			});
		}
	};

	// Iniciar auto-scroll cada 5 segundos
	const startAutoScroll = () => {
		autoScrollInterval = setInterval(scrollOneItem, 5000);
	};

	// Detener auto-scroll
	const stopAutoScroll = () => {
		clearInterval(autoScrollInterval);
	};

	// Scroll manual prev
	if (prevBtn && carousel) {
		prevBtn.addEventListener('click', () => {
			isUserInteracting = true;
			carousel.scrollTo({
				left: carousel.scrollLeft - scrollAmount,
				behavior: 'smooth'
			});
			stopAutoScroll();
			setTimeout(() => {
				isUserInteracting = false;
				startAutoScroll();
			}, 1500);
		});
	}

	// Scroll manual next
	if (nextBtn && carousel) {
		nextBtn.addEventListener('click', () => {
			isUserInteracting = true;
			carousel.scrollTo({
				left: carousel.scrollLeft + scrollAmount,
				behavior: 'smooth'
			});
			stopAutoScroll();
			setTimeout(() => {
				isUserInteracting = false;
				startAutoScroll();
			}, 1500);
		});
	}

	// Mostrar/ocultar botones según posición del scroll
	const updateButtonsVisibility = () => {
		if (!carousel) return;

		const isAtStart = carousel.scrollLeft === 0;
		const isAtEnd = carousel.scrollLeft + carousel.clientWidth >= carousel.scrollWidth - 10;

		if (prevBtn) {
			prevBtn.style.opacity = isAtStart ? '0.3' : '1';
			prevBtn.disabled = isAtStart;
		}

		if (nextBtn) {
			nextBtn.style.opacity = isAtEnd ? '0.3' : '1';
			nextBtn.disabled = isAtEnd;
		}
	};

	carousel?.addEventListener('scroll', updateButtonsVisibility);
	updateButtonsVisibility();

	// Detectar cuando llegó al final para resetear al inicio (loop infinito)
	const resetScrollPosition = () => {
		if (!carousel) return;

		const maxScroll = carousel.scrollWidth - carousel.clientWidth;

		// Si llegó al final del primer set, volver al inicio suavemente
		if (carousel.scrollLeft >= maxScroll - 50) {
			// Resetear sin animación
			carousel.scrollLeft = 0;
		}
	};

	carousel?.addEventListener('scroll', resetScrollPosition);

	// Iniciar auto-scroll al cargar
	startAutoScroll();
</script>

<style>
	.carousel-prev,
	.carousel-next {
		opacity: 1;
	}

	#id {
		scroll-behavior: smooth;
		-webkit-overflow-scrolling: touch;
	}
</style>
